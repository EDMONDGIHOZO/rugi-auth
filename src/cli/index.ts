#!/usr/bin/env node
/**
 * Rugi Auth CLI
 *
 * Command-line interface for setting up and managing rugi-auth projects.
 *
 * Usage:
 *   npx rugi-auth init [project-name]     # Create a new rugi-auth project
 *   npx rugi-auth generate-keys           # Generate RSA key pair
 *   npx rugi-auth setup                   # Initialize app + create superadmin
 */

import { Command } from "commander";
import chalk from "chalk";
import ora from "ora";
import prompts from "prompts";
import fs from "fs";
import path from "path";
import { execSync } from "child_process";
import { generateKeyPairSync } from "crypto";

const program = new Command();

const VERSION = "2.2.0";

// ASCII Art Banner
const banner = `
‚ï¶‚ïê‚ïó‚ï¶ ‚ï¶‚ïî‚ïê‚ïó‚ï¶  ‚ïî‚ïê‚ïó‚ï¶ ‚ï¶‚ïî‚ï¶‚ïó‚ï¶ ‚ï¶
‚ï†‚ï¶‚ïù‚ïë ‚ïë‚ïë ‚ï¶‚ïë  ‚ï†‚ïê‚ï£‚ïë ‚ïë ‚ïë ‚ï†‚ïê‚ï£
‚ï©‚ïö‚ïê‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù‚ï©  ‚ï© ‚ï©‚ïö‚ïê‚ïù ‚ï© ‚ï© ‚ï©
`;

function printBanner() {
  console.log(chalk.cyan(banner));
  console.log(chalk.gray(`  Centralized Authentication Service v${VERSION}\n`));
}

// Template files
const ENV_TEMPLATE = `# Rugi Auth Configuration
# Generated by: npx rugi-auth init

# Database (PostgreSQL)
DATABASE_URL="postgresql://rugi:rugi_password@localhost:5432/rugi_auth"

# Server
PORT=7100
NODE_ENV=development
CORS_ORIGIN=http://localhost:3000,http://localhost:5173

# JWT Configuration
JWT_ISSUER="rugi-auth"
JWT_ACCESS_TOKEN_EXPIRY="7d"
JWT_REFRESH_TOKEN_EXPIRY="30d"

# Keys (generated with: npx rugi-auth generate-keys)
PRIVATE_KEY_PATH="./keys/private.pem"
PUBLIC_KEY_PATH="./keys/public.pem"

# Email (optional - for password resets and OTP)
# SMTP_HOST=smtp.example.com
# SMTP_PORT=587
# SMTP_USER=your-email@example.com
# SMTP_PASS=your-password
# EMAIL_FROM="Rugi Auth <noreply@example.com>"
`;

const DOCKER_COMPOSE_TEMPLATE = `version: "3.8"

services:
  postgres:
    image: postgres:15-alpine
    container_name: rugi-auth-db
    environment:
      POSTGRES_USER: rugi
      POSTGRES_PASSWORD: rugi_password
      POSTGRES_DB: rugi_auth
    ports:
      - "5432:5432"
    volumes:
      - rugi_auth_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U rugi -d rugi_auth"]
      interval: 5s
      timeout: 5s
      retries: 5

volumes:
  rugi_auth_data:
`;

const GITIGNORE_TEMPLATE = `# Dependencies
node_modules/

# Build
dist/

# Environment
.env
.env.local
.env.*.local

# Keys (NEVER commit these!)
keys/
*.pem

# IDE
.idea/
.vscode/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Logs
*.log
logs/
`;

const SERVER_TEMPLATE = `/**
 * Rugi Auth Server
 *
 * This file starts the rugi-auth server.
 * Customize this file to add your own middleware or routes.
 */

import "dotenv/config";

// Import and start the rugi-auth server
import { app } from "rugi-auth";

const PORT = process.env.PORT || 7100;

app.listen(PORT, () => {
  console.log(\`üöÄ Rugi Auth server running on http://localhost:\${PORT}\`);
  console.log(\`üìö API Docs: http://localhost:\${PORT}/docs\`);
  console.log(\`üîë JWKS: http://localhost:\${PORT}/.well-known/jwks.json\`);
});
`;

const PACKAGE_JSON_TEMPLATE = (name: string, includeDashboard: boolean = false) => {
  const base: any = {
    name,
    version: "1.0.0",
    private: true,
    description: "My Rugi Auth Server",
    scripts: {
      dev: "tsx watch src/server.ts",
      build: "tsc",
      start: "node dist/server.js",
      "prisma:generate": "prisma generate",
      "prisma:migrate": "prisma migrate dev",
      "prisma:studio": "prisma studio",
      "generate:keys": "rugi-auth generate-keys",
      "init:app": "rugi-auth init-app",
      "create:superadmin": "rugi-auth create-superadmin",
      setup: "rugi-auth setup",
    },
    dependencies: {
      "rugi-auth": `^${VERSION}`,
      dotenv: "^16.3.1",
    },
    devDependencies: {
      "@types/node": "^20.10.6",
      tsx: "^4.7.0",
      typescript: "^5.3.3",
      prisma: "5.7.1",
    },
  };

  if (includeDashboard) {
    base.scripts["dev:all"] = "npm run dev & npm run dashboard:dev";
    base.scripts["dashboard:dev"] = "cd dashboard && npm run dev";
    base.scripts["dashboard:build"] = "cd dashboard && npm run build";
    base.scripts["dashboard:install"] = "cd dashboard && npm install";
  }

  return base;
};

// Dashboard .env template
const DASHBOARD_ENV_TEMPLATE = (apiUrl: string, clientId: string, clientSecret: string) => `# Rugi Auth Dashboard Configuration
# Auto-generated by: npx rugi-auth init

VITE_API_BASE_URL=${apiUrl}
VITE_DASHBOARD_CLIENT_ID=${clientId}
VITE_DASHBOARD_CLIENT_SECRET=${clientSecret}
`;

// Dashboard GitHub repo - This should be published to GitHub
const DASHBOARD_REPO = "https://github.com/EDMONDGIHOZO/rugi-auth-dashboard.git";

const TSCONFIG_TEMPLATE = {
  compilerOptions: {
    target: "ES2020",
    module: "NodeNext",
    moduleResolution: "NodeNext",
    lib: ["ES2020"],
    outDir: "./dist",
    rootDir: "./src",
    strict: true,
    esModuleInterop: true,
    skipLibCheck: true,
    forceConsistentCasingInFileNames: true,
    declaration: true,
    declarationMap: true,
    sourceMap: true,
  },
  include: ["src/**/*"],
  exclude: ["node_modules", "dist"],
};

// Inline Prisma schema as fallback
function getPrismaSchemaContent(): string {
  return `// Rugi Auth Prisma Schema
// Generated by: npx rugi-auth init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              String            @id @default(uuid()) @db.Uuid
  email           String            @unique @db.VarChar(255)
  passwordHash    String?           @map("password_hash") @db.Text
  isEmailVerified Boolean           @default(false) @map("is_email_verified")
  mfaEnabled      Boolean           @default(false) @map("mfa_enabled")
  mfaSecret       String?           @map("mfa_secret") @db.Text
  optedInApps     String[]          @default([]) @map("opted_in_apps") @db.Uuid
  
  registrationMethod RegistrationMethod @default(EMAIL_PASSWORD) @map("registration_method")
  oauthProvider      String?            @map("oauth_provider") @db.VarChar(50)
  oauthProviderId    String?            @map("oauth_provider_id") @db.VarChar(255)
  
  createdAt       DateTime  @default(now()) @map("created_at") @db.Timestamp(6)

  userAppRoles       UserAppRole[]
  refreshTokens      RefreshToken[]
  authAudits         AuthAudit[]
  assignedRoles      UserAppRole[] @relation("AssignedBy")
  passwordResetTokens PasswordResetToken[]
  emailOTPs          EmailOTP[]

  @@map("users")
  @@index([email])
  @@index([oauthProvider, oauthProviderId])
}

enum RegistrationMethod {
  EMAIL_PASSWORD
  EMAIL_OTP
  GOOGLE
  GITHUB
  MICROSOFT
  FACEBOOK
}

model App {
  id               String    @id @default(uuid()) @db.Uuid
  name             String    @db.VarChar(255)
  clientId         String    @unique @map("client_id") @db.VarChar(255)
  clientSecretHash String?   @map("client_secret_hash") @db.Text
  type             AppType   @default(PUBLIC)
  redirectUris     Json      @map("redirect_uris")
  createdAt        DateTime  @default(now()) @map("created_at") @db.Timestamp(6)

  refreshTokens RefreshToken[]
  authSettings  AppAuthSettings?
  roles         Role[]

  @@map("apps")
  @@index([clientId])
}

enum AppType {
  PUBLIC
  CONFIDENTIAL
}

model Role {
  id        Int      @id @default(autoincrement())
  appId     String   @map("app_id") @db.Uuid
  name      String   @db.VarChar(100)
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamp(6)

  app          App           @relation(fields: [appId], references: [id], onDelete: Cascade)
  userAppRoles UserAppRole[]

  @@unique([appId, name])
  @@map("roles")
  @@index([appId])
}

model UserAppRole {
  id         String   @id @default(uuid()) @db.Uuid
  userId     String   @map("user_id") @db.Uuid
  roleId     Int      @map("role_id")
  assignedBy String?  @map("assigned_by") @db.Uuid
  assignedAt DateTime @default(now()) @map("assigned_at") @db.Timestamp(6)

  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  role       Role     @relation(fields: [roleId], references: [id], onDelete: Cascade)
  assignedByUser User? @relation("AssignedBy", fields: [assignedBy], references: [id])

  @@map("user_app_roles")
  @@unique([userId, roleId])
  @@index([userId])
  @@index([roleId])
}

model RefreshToken {
  token      String   @id @db.VarChar(255)
  userId     String   @map("user_id") @db.Uuid
  appId      String   @map("app_id") @db.Uuid
  createdAt  DateTime @default(now()) @map("created_at") @db.Timestamp(6)
  expiresAt  DateTime @map("expires_at") @db.Timestamp(6)
  revoked    Boolean  @default(false)
  deviceInfo Json?    @map("device_info")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  app  App  @relation(fields: [appId], references: [id], onDelete: Cascade)

  @@map("refresh_tokens")
  @@index([expiresAt])
  @@index([revoked])
  @@index([userId, appId])
}

model AuthAudit {
  id       String      @id @default(uuid()) @db.Uuid
  userId   String?     @map("user_id") @db.Uuid
  action   AuditAction
  metadata Json?
  createdAt DateTime   @default(now()) @map("created_at") @db.Timestamp(6)

  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@map("auth_audit")
  @@index([createdAt])
  @@index([userId])
  @@index([action])
}

enum AuditAction {
  LOGIN
  REFRESH
  REVOKE
  ROLE_ASSIGN
  REGISTER
  PASSWORD_RESET_REQUEST
  PASSWORD_RESET_COMPLETE
  OTP_REQUEST
  OTP_LOGIN
  USER_INVITE
}

model PasswordResetToken {
  id        String   @id @default(uuid()) @db.Uuid
  userId    String   @map("user_id") @db.Uuid
  token     String   @unique @db.VarChar(255)
  expiresAt DateTime @map("expires_at") @db.Timestamp(6)
  used      Boolean  @default(false)
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamp(6)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("password_reset_tokens")
  @@index([token])
  @@index([userId])
  @@index([expiresAt])
  @@index([used])
}

model EmailOTP {
  id        String   @id @default(uuid()) @db.Uuid
  userId    String   @map("user_id") @db.Uuid
  code      String   @db.VarChar(6)
  expiresAt DateTime @map("expires_at") @db.Timestamp(6)
  used      Boolean  @default(false)
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamp(6)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("email_otps")
  @@index([userId])
  @@index([code])
  @@index([expiresAt])
  @@index([used])
}

model AppAuthSettings {
  id        String   @id @default(uuid()) @db.Uuid
  appId     String   @unique @map("app_id") @db.Uuid
  
  emailPasswordEnabled Boolean @default(true) @map("email_password_enabled")
  emailOtpEnabled Boolean @default(false) @map("email_otp_enabled")
  
  googleAuthEnabled Boolean @default(false) @map("google_auth_enabled")
  googleClientId    String? @map("google_client_id") @db.VarChar(255)
  googleClientSecret String? @map("google_client_secret") @db.Text
  
  githubAuthEnabled Boolean @default(false) @map("github_auth_enabled")
  githubClientId    String? @map("github_client_id") @db.VarChar(255)
  githubClientSecret String? @map("github_client_secret") @db.Text
  
  microsoftAuthEnabled Boolean @default(false) @map("microsoft_auth_enabled")
  microsoftClientId    String? @map("microsoft_client_id") @db.VarChar(255)
  microsoftClientSecret String? @map("microsoft_client_secret") @db.Text
  
  facebookAuthEnabled Boolean @default(false) @map("facebook_auth_enabled")
  facebookClientId    String? @map("facebook_client_id") @db.VarChar(255)
  facebookClientSecret String? @map("facebook_client_secret") @db.Text
  
  requireEmailVerification Boolean @default(true) @map("require_email_verification")
  allowRegistration Boolean @default(true) @map("allow_registration")
  
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamp(6)
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamp(6)

  app App @relation(fields: [appId], references: [id], onDelete: Cascade)

  @@map("app_auth_settings")
  @@index([appId])
}
`;
}

// ============================================================
// Commands
// ============================================================

async function initProject(projectName?: string) {
  printBanner();

  console.log(chalk.bold("  Welcome to Rugi Auth! Let's set up your project.\n"));

  // Get project name
  let name = projectName;
  if (!name) {
    const response = await prompts({
      type: "text",
      name: "projectName",
      message: "What is your project name?",
      initial: "my-auth-server",
      validate: (value) =>
        /^[a-z0-9-]+$/.test(value) || "Use lowercase letters, numbers, and hyphens only",
    });
    name = response.projectName;
    if (!name) {
      console.log(chalk.red("\n‚úñ Project creation cancelled.\n"));
      process.exit(1);
    }
  }

  // Ask about dashboard
  const dashboardResponse = await prompts({
    type: "confirm",
    name: "includeDashboard",
    message: "Include admin dashboard? (React frontend for managing users, apps, roles)",
    initial: true,
  });
  const includeDashboard = dashboardResponse.includeDashboard ?? true;

  const projectPath = path.join(process.cwd(), name);

  // Check if directory exists
  if (fs.existsSync(projectPath)) {
    console.log(chalk.red(`\n‚úñ Directory "${name}" already exists.\n`));
    process.exit(1);
  }

  console.log();
  const spinner = ora("Creating project structure...").start();

  try {
    // Create directories
    fs.mkdirSync(projectPath, { recursive: true });
    fs.mkdirSync(path.join(projectPath, "src"), { recursive: true });
    fs.mkdirSync(path.join(projectPath, "keys"), { recursive: true });
    fs.mkdirSync(path.join(projectPath, "prisma"), { recursive: true });

    // Write files
    fs.writeFileSync(path.join(projectPath, ".env"), ENV_TEMPLATE);
    fs.writeFileSync(path.join(projectPath, ".env.example"), ENV_TEMPLATE);
    fs.writeFileSync(path.join(projectPath, ".gitignore"), GITIGNORE_TEMPLATE);
    fs.writeFileSync(
      path.join(projectPath, "docker-compose.yml"),
      DOCKER_COMPOSE_TEMPLATE
    );
    fs.writeFileSync(path.join(projectPath, "src", "server.ts"), SERVER_TEMPLATE);
    fs.writeFileSync(
      path.join(projectPath, "package.json"),
      JSON.stringify(PACKAGE_JSON_TEMPLATE(name, includeDashboard), null, 2)
    );
    fs.writeFileSync(
      path.join(projectPath, "tsconfig.json"),
      JSON.stringify(TSCONFIG_TEMPLATE, null, 2)
    );

    spinner.succeed("Project structure created");

    // Generate RSA keys
    spinner.start("Generating RSA keys...");
    generateKeys(path.join(projectPath, "keys"));
    spinner.succeed("RSA keys generated");

    // Copy Prisma schema - try multiple paths for different install contexts
    spinner.start("Setting up Prisma schema...");
    const possibleSchemaPaths = [
      // When running from npm package (node_modules/rugi-auth/dist/cli)
      path.join(__dirname, "..", "..", "prisma", "schema.prisma"),
      // When running from source (src/cli)
      path.join(__dirname, "..", "..", "..", "prisma", "schema.prisma"),
      // When running from project root
      path.join(process.cwd(), "node_modules", "rugi-auth", "prisma", "schema.prisma"),
    ];
    
    let schemaFound = false;
    for (const schemaPath of possibleSchemaPaths) {
      if (fs.existsSync(schemaPath)) {
        fs.copyFileSync(schemaPath, path.join(projectPath, "prisma", "schema.prisma"));
        schemaFound = true;
        break;
      }
    }
    
    if (!schemaFound) {
      // Download schema from npm registry or use inline schema
      fs.writeFileSync(
        path.join(projectPath, "prisma", "schema.prisma"),
        getPrismaSchemaContent()
      );
    }
    spinner.succeed("Prisma schema configured");

    // Install dependencies
    spinner.start("Installing backend dependencies...");
    execSync("npm install", { cwd: projectPath, stdio: "pipe" });
    spinner.succeed("Backend dependencies installed");

    // Setup dashboard if requested
    if (includeDashboard) {
      spinner.start("Cloning admin dashboard...");
      try {
        execSync(`git clone --depth 1 ${DASHBOARD_REPO} dashboard`, { 
          cwd: projectPath, 
          stdio: "pipe" 
        });
        // Remove .git from cloned dashboard
        fs.rmSync(path.join(projectPath, "dashboard", ".git"), { recursive: true, force: true });
        spinner.succeed("Admin dashboard cloned");

        spinner.start("Installing dashboard dependencies...");
        execSync("npm install", { cwd: path.join(projectPath, "dashboard"), stdio: "pipe" });
        spinner.succeed("Dashboard dependencies installed");

        // Create placeholder .env for dashboard (will be configured during setup)
        fs.writeFileSync(
          path.join(projectPath, "dashboard", ".env"),
          DASHBOARD_ENV_TEMPLATE("http://localhost:7100", "rugi-dashboard-dev", "WILL_BE_SET_DURING_SETUP")
        );
      } catch (dashboardError: any) {
        spinner.warn("Could not clone dashboard (will need manual setup)");
        console.log(chalk.gray(`    Clone manually: git clone ${DASHBOARD_REPO} dashboard`));
      }
    }

    // Success message
    console.log();
    console.log(chalk.green.bold("  ‚úì Project created successfully!\n"));
    console.log(chalk.bold("  Next steps:\n"));
    console.log(chalk.cyan(`  1. ${chalk.bold(`cd ${name}`)}`));
    console.log(chalk.cyan(`  2. ${chalk.bold("docker-compose up -d")}        ${chalk.gray("# Start PostgreSQL")}`));
    console.log(chalk.cyan(`  3. ${chalk.bold("npm run prisma:migrate")}      ${chalk.gray("# Run migrations")}`));
    console.log(chalk.cyan(`  4. ${chalk.bold("npm run setup")}               ${chalk.gray("# Initialize app + superadmin")}`));
    
    if (includeDashboard) {
      console.log(chalk.cyan(`  5. ${chalk.bold("npm run dev:all")}             ${chalk.gray("# Start backend + dashboard")}`));
      console.log();
      console.log(chalk.gray(`  Backend:   ${chalk.cyan("http://localhost:7100")}`));
      console.log(chalk.gray(`  Dashboard: ${chalk.cyan("http://localhost:5173")}`));
    } else {
      console.log(chalk.cyan(`  5. ${chalk.bold("npm run dev")}                 ${chalk.gray("# Start development server")}`));
      console.log();
      console.log(chalk.gray(`  Server: ${chalk.cyan("http://localhost:7100")}`));
    }
    
    console.log(chalk.gray(`  API Docs: ${chalk.cyan("http://localhost:7100/docs")}`));
    console.log();
  } catch (error: any) {
    spinner.fail("Failed to create project");
    console.error(chalk.red(`\nError: ${error.message}\n`));
    process.exit(1);
  }
}

function generateKeys(keysDir?: string) {
  const dir = keysDir || path.join(process.cwd(), "keys");

  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }

  const privateKeyPath = path.join(dir, "private.pem");
  const publicKeyPath = path.join(dir, "public.pem");

  if (fs.existsSync(privateKeyPath) && !keysDir) {
    console.log(chalk.yellow("\n‚ö† Keys already exist. Delete them to regenerate.\n"));
    console.log(`  Private key: ${privateKeyPath}`);
    console.log(`  Public key: ${publicKeyPath}\n`);
    return;
  }

  const { publicKey, privateKey } = generateKeyPairSync("rsa", {
    modulusLength: 2048,
    publicKeyEncoding: { type: "spki", format: "pem" },
    privateKeyEncoding: { type: "pkcs8", format: "pem" },
  });

  fs.writeFileSync(privateKeyPath, privateKey, { mode: 0o600 });
  fs.writeFileSync(publicKeyPath, publicKey, { mode: 0o644 });

  if (!keysDir) {
    console.log(chalk.green("\n‚úì RSA keys generated successfully!\n"));
    console.log(`  Private key: ${privateKeyPath}`);
    console.log(`  Public key: ${publicKeyPath}`);
    console.log(chalk.yellow("\n  ‚ö† Never commit the private key to version control!\n"));
  }
}

interface AppCredentials {
  clientId: string;
  clientSecret: string;
  appName: string;
}

async function initApp(silent: boolean = false): Promise<AppCredentials | null> {
  if (!silent) {
    printBanner();
  }

  const spinner = ora("Initializing default app...").start();

  try {
    // Dynamic import to avoid loading Prisma when not needed
    const { PrismaClient } = await import("@prisma/client");
    const { hashPassword } = await import("../services/password.service");
    const { v4: uuidv4 } = await import("uuid");

    const prisma = new PrismaClient();

    const DEFAULT_APP_NAME = "Rugi Dashboard";
    const DEFAULT_CLIENT_ID = "rugi-dashboard-dev";

    let app = await prisma.app.findFirst({
      where: { name: DEFAULT_APP_NAME },
      include: { authSettings: true },
    });

    const clientSecret = uuidv4() + uuidv4();
    const clientSecretHash = await hashPassword(clientSecret);

    if (!app) {
      app = await prisma.app.create({
        data: {
          name: DEFAULT_APP_NAME,
          clientId: DEFAULT_CLIENT_ID,
          clientSecretHash,
          type: "CONFIDENTIAL",
          redirectUris: [
            "http://localhost:3000/callback",
            "http://localhost:3001/callback",
            "http://localhost:5173/callback",
          ],
          authSettings: {
            create: {
              emailPasswordEnabled: true,
              emailOtpEnabled: false,
              googleAuthEnabled: false,
              githubAuthEnabled: false,
              microsoftAuthEnabled: false,
              facebookAuthEnabled: false,
              requireEmailVerification: false,
              allowRegistration: true,
            },
          },
        },
        include: { authSettings: true },
      });
    } else {
      app = await prisma.app.update({
        where: { id: app.id },
        data: { clientId: DEFAULT_CLIENT_ID, clientSecretHash },
        include: { authSettings: true },
      });
    }

    await prisma.$disconnect();

    spinner.succeed("Default app initialized");

    if (!silent) {
      console.log();
      console.log(chalk.bold("  üì± App Credentials\n"));
      console.log(chalk.gray("  ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"));
      console.log(`  ${chalk.cyan("App Name:")}      ${app.name}`);
      console.log(`  ${chalk.cyan("Client ID:")}     ${DEFAULT_CLIENT_ID}`);
      console.log(`  ${chalk.cyan("Client Secret:")} ${clientSecret}`);
      console.log(`  ${chalk.cyan("Type:")}          ${app.type}`);
      console.log(chalk.gray("  ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"));
      console.log(chalk.yellow("  üíæ Save these credentials - the secret won't be shown again!\n"));
    }

    return {
      clientId: DEFAULT_CLIENT_ID,
      clientSecret,
      appName: app.name,
    };
  } catch (error: any) {
    spinner.fail("Failed to initialize app");
    console.error(chalk.red(`\nError: ${error.message}\n`));
    console.log(chalk.gray("  Make sure the database is running and migrations are applied.\n"));
    if (!silent) {
      process.exit(1);
    }
    return null;
  }
}

async function createSuperadmin() {
  printBanner();

  console.log(chalk.bold("  Create your first superadmin account\n"));

  // Get email
  const emailResponse = await prompts({
    type: "text",
    name: "email",
    message: "Email address",
    validate: (value) =>
      /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value) || "Enter a valid email address",
  });

  if (!emailResponse.email) {
    console.log(chalk.red("\n‚úñ Superadmin creation cancelled.\n"));
    process.exit(1);
  }

  // Get password
  const passwordResponse = await prompts({
    type: "password",
    name: "password",
    message: "Password (min 8 characters)",
    validate: (value) =>
      value.length >= 8 || "Password must be at least 8 characters",
  });

  if (!passwordResponse.password) {
    console.log(chalk.red("\n‚úñ Superadmin creation cancelled.\n"));
    process.exit(1);
  }

  // Confirm password
  const confirmResponse = await prompts({
    type: "password",
    name: "confirmPassword",
    message: "Confirm password",
    validate: (value) =>
      value === passwordResponse.password || "Passwords do not match",
  });

  if (!confirmResponse.confirmPassword) {
    console.log(chalk.red("\n‚úñ Superadmin creation cancelled.\n"));
    process.exit(1);
  }

  const response = {
    email: emailResponse.email,
    password: passwordResponse.password,
  };

  const spinner = ora("Creating superadmin...").start();

  try {
    const { PrismaClient } = await import("@prisma/client");
    const { hashPassword } = await import("../services/password.service");

    const prisma = new PrismaClient();

    // Check if user exists
    const existingUser = await prisma.user.findUnique({
      where: { email: response.email },
    });

    if (existingUser) {
      spinner.fail("User with this email already exists");
      await prisma.$disconnect();
      process.exit(1);
    }

    // Get default app
    const app = await prisma.app.findFirst({
      where: { clientId: "rugi-dashboard-dev" },
    });

    if (!app) {
      spinner.fail("Default app not found. Run 'npx rugi-auth init-app' first.");
      await prisma.$disconnect();
      process.exit(1);
    }

    // Create user
    const passwordHash = await hashPassword(response.password);
    const user = await prisma.user.create({
      data: {
        email: response.email,
        passwordHash,
        isEmailVerified: true,
        optedInApps: [app.id],
      },
    });

    // Create superadmin and owner roles if they don't exist
    const superadminRole = await prisma.role.upsert({
      where: { appId_name: { appId: app.id, name: "superadmin" } },
      create: { appId: app.id, name: "superadmin" },
      update: {},
    });

    const ownerRole = await prisma.role.upsert({
      where: { appId_name: { appId: app.id, name: "owner" } },
      create: { appId: app.id, name: "owner" },
      update: {},
    });

    // Assign roles to user
    await prisma.userAppRole.createMany({
      data: [
        { userId: user.id, roleId: superadminRole.id },
        { userId: user.id, roleId: ownerRole.id },
      ],
    });

    await prisma.$disconnect();

    spinner.succeed("Superadmin created successfully");

    console.log();
    console.log(chalk.bold("  üë§ Superadmin Account\n"));
    console.log(chalk.gray("  ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"));
    console.log(`  ${chalk.cyan("Email:")}  ${response.email}`);
    console.log(`  ${chalk.cyan("Roles:")}  superadmin, owner`);
    console.log(chalk.gray("  ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"));
    console.log(chalk.green("  üéâ You can now log in to your Rugi Auth server!\n"));
  } catch (error: any) {
    spinner.fail("Failed to create superadmin");
    console.error(chalk.red(`\nError: ${error.message}\n`));
    process.exit(1);
  }
}

async function runSetup() {
  printBanner();

  console.log(chalk.bold("  Running complete setup...\n"));

  // Step 1: Generate keys if needed
  const keysDir = path.join(process.cwd(), "keys");
  const privateKeyPath = path.join(keysDir, "private.pem");

  if (!fs.existsSync(privateKeyPath)) {
    const spinner = ora("Generating RSA keys...").start();
    generateKeys(keysDir);
    spinner.succeed("RSA keys generated");
  } else {
    console.log(chalk.gray("  ‚úì RSA keys already exist\n"));
  }

  // Step 2: Initialize app and get credentials
  const credentials = await initApp(true);
  
  if (credentials) {
    console.log();
    console.log(chalk.bold("  üì± App Credentials\n"));
    console.log(chalk.gray("  ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"));
    console.log(`  ${chalk.cyan("App Name:")}      ${credentials.appName}`);
    console.log(`  ${chalk.cyan("Client ID:")}     ${credentials.clientId}`);
    console.log(`  ${chalk.cyan("Client Secret:")} ${credentials.clientSecret}`);
    console.log(chalk.gray("  ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"));
    
    // Step 3: Configure dashboard if it exists
    const dashboardPath = path.join(process.cwd(), "dashboard");
    const dashboardEnvPath = path.join(dashboardPath, ".env");
    
    if (fs.existsSync(dashboardPath)) {
      const spinner = ora("Configuring dashboard...").start();
      fs.writeFileSync(
        dashboardEnvPath,
        DASHBOARD_ENV_TEMPLATE("http://localhost:7100", credentials.clientId, credentials.clientSecret)
      );
      spinner.succeed("Dashboard configured with credentials");
    }
  }

  // Step 4: Create superadmin
  await createSuperadmin();

  // Check if dashboard exists for final message
  const hasDashboard = fs.existsSync(path.join(process.cwd(), "dashboard"));

  console.log(chalk.green.bold("\n  ‚úì Setup complete!\n"));
  
  if (hasDashboard) {
    console.log(chalk.bold("  Start your servers:\n"));
    console.log(`    ${chalk.cyan("npm run dev:all")}     ${chalk.gray("# Backend + Dashboard")}`);
    console.log();
    console.log(chalk.gray("  Or separately:"));
    console.log(`    ${chalk.cyan("npm run dev")}          ${chalk.gray("# Backend only (port 7100)")}`);
    console.log(`    ${chalk.cyan("npm run dashboard:dev")} ${chalk.gray("# Dashboard only (port 5173)")}`);
  } else {
    console.log(`  Start your server with: ${chalk.cyan("npm run dev")}`);
  }
  
  console.log();
  console.log(chalk.bold("  üîê Login Credentials:\n"));
  console.log(chalk.gray("  Use the email and password you just created to log in."));
  if (hasDashboard) {
    console.log(chalk.gray(`  Dashboard URL: ${chalk.cyan("http://localhost:5173")}`));
  }
  console.log();
}

// ============================================================
// CLI Program Definition
// ============================================================

program
  .name("rugi-auth")
  .description("Centralized authentication service CLI")
  .version(VERSION);

program
  .command("init [project-name]")
  .description("Create a new rugi-auth project")
  .action(initProject);

program
  .command("generate-keys")
  .description("Generate RSA key pair for JWT signing")
  .action(() => generateKeys());

program
  .command("init-app")
  .description("Initialize the default application with credentials")
  .action(async () => {
    await initApp(false);
  });

program
  .command("create-superadmin")
  .description("Create a superadmin user")
  .action(createSuperadmin);

program
  .command("setup")
  .description("Run complete setup (keys + app + superadmin)")
  .action(runSetup);

program.parse();

