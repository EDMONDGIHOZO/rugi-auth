#!/usr/bin/env node
/**
 * Rugi Auth CLI
 *
 * Command-line interface for setting up and managing rugi-auth projects.
 *
 * Usage:
 *   npx rugi-auth init [project-name]     # Create a new rugi-auth project
 *   npx rugi-auth generate-keys           # Generate RSA key pair
 *   npx rugi-auth setup                   # Initialize app + create superadmin
 */

import { Command } from "commander";
import chalk from "chalk";
import ora from "ora";
import prompts from "prompts";
import fs from "fs";
import path from "path";
import { execSync } from "child_process";
import { generateKeyPairSync } from "crypto";
import https from "https";

const program = new Command();

const VERSION = "2.4.2";

// ASCII Art Banner
const banner = `
â•¦â•â•—â•¦ â•¦â•”â•â•—â•¦  â•”â•â•—â•¦ â•¦â•”â•¦â•—â•¦ â•¦
â• â•¦â•â•‘ â•‘â•‘ â•¦â•‘  â• â•â•£â•‘ â•‘ â•‘ â• â•â•£
â•©â•šâ•â•šâ•â•â•šâ•â•â•©  â•© â•©â•šâ•â• â•© â•© â•©
SECURE YOUR APPS.
`;

function printBanner() {
  console.log(chalk.cyan(banner));
  console.log(chalk.gray(`  Centralized Authentication Service v${VERSION}\n`));
}

/**
 * Compare two semantic version strings
 * Returns: 1 if v1 > v2, -1 if v1 < v2, 0 if equal
 */
function compareVersions(v1: string, v2: string): number {
  const parts1 = v1.split(".").map(Number);
  const parts2 = v2.split(".").map(Number);

  for (let i = 0; i < Math.max(parts1.length, parts2.length); i++) {
    const part1 = parts1[i] || 0;
    const part2 = parts2[i] || 0;

    if (part1 > part2) return 1;
    if (part1 < part2) return -1;
  }

  return 0;
}

/**
 * Fetch the latest version from npm registry
 */
async function getLatestVersion(): Promise<string | null> {
  return new Promise((resolve) => {
    const options = {
      hostname: "registry.npmjs.org",
      path: "/rugi-auth",
      method: "GET",
      headers: {
        "User-Agent": "rugi-auth-cli",
      },
      timeout: 3000, // 3 second timeout
    };

    const req = https.request(options, (res) => {
      let data = "";

      res.on("data", (chunk) => {
        data += chunk;
      });

      res.on("end", () => {
        try {
          const packageInfo = JSON.parse(data);
          const latestVersion = packageInfo["dist-tags"]?.latest || null;
          resolve(latestVersion);
        } catch (error) {
          // Silently fail - don't block CLI if check fails
          resolve(null);
        }
      });
    });

    req.on("error", () => {
      // Silently fail - don't block CLI if check fails
      resolve(null);
    });

    req.on("timeout", () => {
      req.destroy();
      resolve(null);
    });

    req.end();
  });
}

/**
 * Check for updates and display message if newer version is available
 * Runs asynchronously and doesn't block CLI execution
 */
async function checkForUpdates(): Promise<void> {
  // Skip check in CI environments or if explicitly disabled
  if (process.env.CI || process.env.RUGI_AUTH_SKIP_UPDATE_CHECK) {
    return;
  }

  try {
    const latestVersion = await getLatestVersion();

    if (!latestVersion) {
      return; // Silently fail if we can't fetch version
    }

    if (compareVersions(latestVersion, VERSION) > 0) {
      // Newer version available
      console.log(chalk.yellow("\n  âš  Update available!"));
      console.log(chalk.gray(`  Current version: ${VERSION}`));
      console.log(chalk.green(`  Latest version: ${latestVersion}`));
      console.log(
        chalk.cyan(`  Update with: npm install -g rugi-auth@latest\n`)
      );
    }
  } catch (error) {
    // Silently fail - don't block CLI if check fails
  }
}

// Template files
const ENV_TEMPLATE = `# Rugi Auth Configuration
# Generated by: npx rugi-auth init

# Database (PostgreSQL)
DATABASE_URL="postgresql://rugi:rugi_password@localhost:5433/rugi_auth"

# Server
PORT=7100
NODE_ENV=development
CORS_ORIGIN=http://localhost:3000,http://localhost:5173

# JWT Configuration
JWT_ISSUER="rugi-auth"
JWT_ACCESS_TOKEN_EXPIRY="7d"
JWT_REFRESH_TOKEN_EXPIRY="30d"

# Keys (generated with: npx rugi-auth generate-keys)
PRIVATE_KEY_PATH="./keys/private.pem"
PUBLIC_KEY_PATH="./keys/public.pem"

# Email (optional - for password resets and OTP)
# SMTP_HOST=smtp.example.com
# SMTP_PORT=587
# SMTP_USER=your-email@example.com
# SMTP_PASS=your-password
# EMAIL_FROM="Rugi Auth <noreply@example.com>"
`;

function getDockerComposeTemplate(projectName: string): string {
  // Sanitize project name for use in container names (lowercase, hyphens only)
  const sanitizedName = projectName.toLowerCase().replace(/[^a-z0-9-]/g, "-");
  const dbContainerName = `${sanitizedName}-db`;
  const redisContainerName = `${sanitizedName}-redis`;
  const postgresVolume = `${sanitizedName}_postgres_data`;
  const redisVolume = `${sanitizedName}_redis_data`;

  return `version: "3.8"

services:
  postgres:
    image: postgres:15-alpine
    container_name: ${dbContainerName}
    environment:
      POSTGRES_USER: \${POSTGRES_USER:-rugi}
      POSTGRES_PASSWORD: \${POSTGRES_PASSWORD:-rugi_password}
      POSTGRES_DB: \${POSTGRES_DB:-rugi_auth}
      # These ensure the database and user are created even if not in .env
      POSTGRES_INITDB_ARGS: "--encoding=UTF8"
    ports:
      - "5433:5432"
    volumes:
      - ${postgresVolume}:/var/lib/postgresql/data
      - ./docker/init-db.sh:/docker-entrypoint-initdb.d/init-db.sh
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U \${POSTGRES_USER:-rugi} -d \${POSTGRES_DB:-rugi_auth}"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:alpine
    container_name: ${redisContainerName}
    ports:
      - "6380:6379"
    volumes:
      - ${redisVolume}:/data
    # For production: Add password protection
    # command: redis-server --appendonly yes --requirepass \${REDIS_PASSWORD}
    # For development: No password (default)
    command: redis-server --appendonly yes

  # Optional: Node.js development service
  # Uncomment if you want to run the app in Docker
  # app:
  #   build:
  #     context: .
  #     dockerfile: Dockerfile
  #   container_name: ${sanitizedName}-app
  #   environment:
  #     NODE_ENV: development
  #     DATABASE_URL: postgresql://rugi:rugi_password@postgres:5432/rugi_auth?schema=public
  #     PORT: 3000
  #   ports:
  #     - "3000:3000"
  #   volumes:
  #     - .:/app
  #     - /app/node_modules
  #   depends_on:
  #     postgres:
  #       condition: service_healthy
  #   command: npm run dev

volumes:
  ${postgresVolume}:
  ${redisVolume}:
`;
}

const GITIGNORE_TEMPLATE = `# Dependencies
node_modules/

# Build
dist/

# Environment
.env
.env.local
.env.*.local

# Keys (NEVER commit these!)
keys/
*.pem

# IDE
.idea/
.vscode/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Logs
*.log
logs/
`;

const SERVER_TEMPLATE = `/**
 * Rugi Auth Server
 *
 * This file starts the rugi-auth server.
 * Customize this file to add your own middleware or routes.
 */

import "dotenv/config";

// Import and start the rugi-auth server
import { app } from "rugi-auth";

const PORT = process.env.PORT || 7100;

app.listen(PORT, () => {
  console.log(\`ðŸš€ Rugi Auth server running on http://localhost:\${PORT}\`);
  console.log(\`ðŸ“š API Docs: http://localhost:\${PORT}/docs\`);
  console.log(\`ðŸ”‘ JWKS: http://localhost:\${PORT}/.well-known/jwks.json\`);
});
`;

const PACKAGE_JSON_TEMPLATE = (
  name: string,
  includeDashboard: boolean = false
) => {
  const base: any = {
    name,
    version: "1.0.0",
    private: true,
    description: "My Rugi Auth Server",
    scripts: {
      dev: "tsx watch src/server.ts",
      build: "tsc",
      start: "node dist/server.js",
      "prisma:generate": "prisma generate",
      "prisma:migrate": "prisma migrate dev",
      "prisma:studio": "prisma studio",
      "generate:keys": "rugi-auth generate-keys",
      "init:app": "rugi-auth init-app",
      "create:superadmin": "rugi-auth create-superadmin",
      setup: "rugi-auth setup",
    },
    dependencies: {
      "rugi-auth": `^${VERSION}`,
      dotenv: "^16.3.1",
    },
    devDependencies: {
      "@types/node": "^20.10.6",
      tsx: "^4.7.0",
      typescript: "^5.3.3",
      prisma: "5.7.1",
    },
  };

  if (includeDashboard) {
    base.scripts["dev:all"] =
      "npm run dev & if [ -d dashboard ]; then cd dashboard && npm run dev; else echo 'âš  Dashboard not found. Skipping dashboard dev server.'; echo 'Run: npx rugi-auth diagnose-dashboard for details'; fi";
    base.scripts["dashboard:dev"] =
      "if [ -d dashboard ]; then cd dashboard && npm run dev; else echo 'Dashboard directory not found.'; echo 'Run: npx rugi-auth diagnose-dashboard for details' && exit 1; fi";
    base.scripts["dashboard:build"] =
      "if [ -d dashboard ]; then cd dashboard && npm run build; else echo 'Dashboard directory not found.'; echo 'Run: npx rugi-auth diagnose-dashboard for details' && exit 1; fi";
    base.scripts["dashboard:install"] =
      "if [ -d dashboard ]; then cd dashboard && npm install; else echo 'Dashboard directory not found.'; echo 'Run: npx rugi-auth diagnose-dashboard for details' && exit 1; fi";
  }

  return base;
};

// Dashboard .env template
const DASHBOARD_ENV_TEMPLATE = (
  apiUrl: string,
  clientId: string,
  clientSecret: string
) => `# Rugi Auth Dashboard Configuration
# Auto-generated by: npx rugi-auth init

VITE_API_BASE_URL=${apiUrl}
VITE_DASHBOARD_CLIENT_ID=${clientId}
VITE_DASHBOARD_CLIENT_SECRET=${clientSecret}
`;

// Dashboard GitHub repo - This should be published to GitHub
const DASHBOARD_REPO =
  "https://github.com/EDMONDGIHOZO/rugi-auth-dashboard.git";

const TSCONFIG_TEMPLATE = {
  compilerOptions: {
    target: "ES2020",
    module: "NodeNext",
    moduleResolution: "NodeNext",
    lib: ["ES2020"],
    outDir: "./dist",
    rootDir: "./src",
    strict: true,
    esModuleInterop: true,
    skipLibCheck: true,
    forceConsistentCasingInFileNames: true,
    declaration: true,
    declarationMap: true,
    sourceMap: true,
  },
  include: ["src/**/*"],
  exclude: ["node_modules", "dist"],
};

// Inline Prisma schema as fallback
function getPrismaSchemaContent(): string {
  return `// Rugi Auth Prisma Schema
// Generated by: npx rugi-auth init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              String            @id @default(uuid()) @db.Uuid
  email           String            @unique @db.VarChar(255)
  passwordHash    String?           @map("password_hash") @db.Text
  isEmailVerified Boolean           @default(false) @map("is_email_verified")
  mfaEnabled      Boolean           @default(false) @map("mfa_enabled")
  mfaSecret       String?           @map("mfa_secret") @db.Text
  optedInApps     String[]          @default([]) @map("opted_in_apps") @db.Uuid
  
  registrationMethod RegistrationMethod @default(EMAIL_PASSWORD) @map("registration_method")
  oauthProvider      String?            @map("oauth_provider") @db.VarChar(50)
  oauthProviderId    String?            @map("oauth_provider_id") @db.VarChar(255)
  
  createdAt       DateTime  @default(now()) @map("created_at") @db.Timestamp(6)

  userAppRoles       UserAppRole[]
  refreshTokens      RefreshToken[]
  authAudits         AuthAudit[]
  assignedRoles      UserAppRole[] @relation("AssignedBy")
  passwordResetTokens PasswordResetToken[]
  emailOTPs          EmailOTP[]

  @@map("users")
  @@index([email])
  @@index([oauthProvider, oauthProviderId])
}

enum RegistrationMethod {
  EMAIL_PASSWORD
  EMAIL_OTP
  GOOGLE
  GITHUB
  MICROSOFT
  FACEBOOK
}

model App {
  id               String    @id @default(uuid()) @db.Uuid
  name             String    @db.VarChar(255)
  clientId         String    @unique @map("client_id") @db.VarChar(255)
  clientSecretHash String?   @map("client_secret_hash") @db.Text
  type             AppType   @default(PUBLIC)
  redirectUris     Json      @map("redirect_uris")
  createdAt        DateTime  @default(now()) @map("created_at") @db.Timestamp(6)

  refreshTokens RefreshToken[]
  authSettings  AppAuthSettings?
  roles         Role[]

  @@map("apps")
  @@index([clientId])
}

enum AppType {
  PUBLIC
  CONFIDENTIAL
}

model Role {
  id        Int      @id @default(autoincrement())
  appId     String   @map("app_id") @db.Uuid
  name      String   @db.VarChar(100)
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamp(6)

  app          App           @relation(fields: [appId], references: [id], onDelete: Cascade)
  userAppRoles UserAppRole[]

  @@unique([appId, name])
  @@map("roles")
  @@index([appId])
}

model UserAppRole {
  id         String   @id @default(uuid()) @db.Uuid
  userId     String   @map("user_id") @db.Uuid
  roleId     Int      @map("role_id")
  assignedBy String?  @map("assigned_by") @db.Uuid
  assignedAt DateTime @default(now()) @map("assigned_at") @db.Timestamp(6)

  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  role       Role     @relation(fields: [roleId], references: [id], onDelete: Cascade)
  assignedByUser User? @relation("AssignedBy", fields: [assignedBy], references: [id])

  @@map("user_app_roles")
  @@unique([userId, roleId])
  @@index([userId])
  @@index([roleId])
}

model RefreshToken {
  token      String   @id @db.VarChar(255)
  userId     String   @map("user_id") @db.Uuid
  appId      String   @map("app_id") @db.Uuid
  createdAt  DateTime @default(now()) @map("created_at") @db.Timestamp(6)
  expiresAt  DateTime @map("expires_at") @db.Timestamp(6)
  revoked    Boolean  @default(false)
  deviceInfo Json?    @map("device_info")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  app  App  @relation(fields: [appId], references: [id], onDelete: Cascade)

  @@map("refresh_tokens")
  @@index([expiresAt])
  @@index([revoked])
  @@index([userId, appId])
}

model AuthAudit {
  id       String      @id @default(uuid()) @db.Uuid
  userId   String?     @map("user_id") @db.Uuid
  action   AuditAction
  metadata Json?
  createdAt DateTime   @default(now()) @map("created_at") @db.Timestamp(6)

  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@map("auth_audit")
  @@index([createdAt])
  @@index([userId])
  @@index([action])
}

enum AuditAction {
  LOGIN
  REFRESH
  REVOKE
  ROLE_ASSIGN
  REGISTER
  PASSWORD_RESET_REQUEST
  PASSWORD_RESET_COMPLETE
  OTP_REQUEST
  OTP_LOGIN
  USER_INVITE
}

model PasswordResetToken {
  id        String   @id @default(uuid()) @db.Uuid
  userId    String   @map("user_id") @db.Uuid
  token     String   @unique @db.VarChar(255)
  expiresAt DateTime @map("expires_at") @db.Timestamp(6)
  used      Boolean  @default(false)
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamp(6)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("password_reset_tokens")
  @@index([token])
  @@index([userId])
  @@index([expiresAt])
  @@index([used])
}

model EmailOTP {
  id        String   @id @default(uuid()) @db.Uuid
  userId    String   @map("user_id") @db.Uuid
  code      String   @db.VarChar(6)
  expiresAt DateTime @map("expires_at") @db.Timestamp(6)
  used      Boolean  @default(false)
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamp(6)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("email_otps")
  @@index([userId])
  @@index([code])
  @@index([expiresAt])
  @@index([used])
}

model AppAuthSettings {
  id        String   @id @default(uuid()) @db.Uuid
  appId     String   @unique @map("app_id") @db.Uuid
  
  emailPasswordEnabled Boolean @default(true) @map("email_password_enabled")
  emailOtpEnabled Boolean @default(false) @map("email_otp_enabled")
  
  googleAuthEnabled Boolean @default(false) @map("google_auth_enabled")
  googleClientId    String? @map("google_client_id") @db.VarChar(255)
  googleClientSecret String? @map("google_client_secret") @db.Text
  
  githubAuthEnabled Boolean @default(false) @map("github_auth_enabled")
  githubClientId    String? @map("github_client_id") @db.VarChar(255)
  githubClientSecret String? @map("github_client_secret") @db.Text
  
  microsoftAuthEnabled Boolean @default(false) @map("microsoft_auth_enabled")
  microsoftClientId    String? @map("microsoft_client_id") @db.VarChar(255)
  microsoftClientSecret String? @map("microsoft_client_secret") @db.Text
  
  facebookAuthEnabled Boolean @default(false) @map("facebook_auth_enabled")
  facebookClientId    String? @map("facebook_client_id") @db.VarChar(255)
  facebookClientSecret String? @map("facebook_client_secret") @db.Text
  
  requireEmailVerification Boolean @default(true) @map("require_email_verification")
  allowRegistration Boolean @default(true) @map("allow_registration")
  
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamp(6)
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamp(6)

  app App @relation(fields: [appId], references: [id], onDelete: Cascade)

  @@map("app_auth_settings")
  @@index([appId])
}
`;
}

// ============================================================
// Commands
// ============================================================

async function initProject(projectName?: string) {
  printBanner();

  console.log(
    chalk.bold("  Welcome to Rugi Auth! Let's set up your project.\n")
  );

  // Get project name
  let name = projectName;
  if (!name) {
    const response = await prompts({
      type: "text",
      name: "projectName",
      message: "What is your project name?",
      initial: "my-auth-server",
      validate: (value) =>
        /^[a-z0-9-]+$/.test(value) ||
        "Use lowercase letters, numbers, and hyphens only",
    });
    name = response.projectName;
    if (!name) {
      console.log(chalk.red("\nâœ– Project creation cancelled.\n"));
      process.exit(1);
    }
  }

  // Ask about dashboard
  const dashboardResponse = await prompts({
    type: "confirm",
    name: "includeDashboard",
    message:
      "Include admin dashboard? (React frontend for managing users, apps, roles)",
    initial: true,
  });
  const includeDashboard = dashboardResponse.includeDashboard ?? true;

  const projectPath = path.join(process.cwd(), name);

  // Check if directory exists
  if (fs.existsSync(projectPath)) {
    console.log(chalk.red(`\nâœ– Directory "${name}" already exists.\n`));
    process.exit(1);
  }

  console.log();
  const spinner = ora("Creating project structure...").start();

  try {
    // Create directories
    fs.mkdirSync(projectPath, { recursive: true });
    fs.mkdirSync(path.join(projectPath, "src"), { recursive: true });
    fs.mkdirSync(path.join(projectPath, "keys"), { recursive: true });
    fs.mkdirSync(path.join(projectPath, "prisma"), { recursive: true });
    fs.mkdirSync(path.join(projectPath, "docker"), { recursive: true });

    // Write files
    fs.writeFileSync(path.join(projectPath, ".env"), ENV_TEMPLATE);
    fs.writeFileSync(path.join(projectPath, ".env.example"), ENV_TEMPLATE);
    fs.writeFileSync(path.join(projectPath, ".gitignore"), GITIGNORE_TEMPLATE);
    fs.writeFileSync(
      path.join(projectPath, "docker-compose.yml"),
      getDockerComposeTemplate(name)
    );
    fs.writeFileSync(
      path.join(projectPath, "src", "server.ts"),
      SERVER_TEMPLATE
    );

    // Copy docker init script
    const possibleDockerScriptPaths = [
      // When running from npm package (node_modules/rugi-auth/dist/cli)
      path.join(__dirname, "..", "..", "..", "docker", "init-db.sh"),
      // When running from source (src/cli)
      path.join(__dirname, "..", "..", "..", "docker", "init-db.sh"),
      // When running from project root
      path.join(
        process.cwd(),
        "node_modules",
        "rugi-auth",
        "docker",
        "init-db.sh"
      ),
    ];

    let dockerScriptFound = false;
    for (const dockerScriptPath of possibleDockerScriptPaths) {
      if (fs.existsSync(dockerScriptPath)) {
        fs.copyFileSync(
          dockerScriptPath,
          path.join(projectPath, "docker", "init-db.sh")
        );
        // Make it executable
        fs.chmodSync(path.join(projectPath, "docker", "init-db.sh"), 0o755);
        dockerScriptFound = true;
        break;
      }
    }

    if (!dockerScriptFound) {
      // Create a basic init-db.sh if we can't find the original
      fs.writeFileSync(
        path.join(projectPath, "docker", "init-db.sh"),
        `#!/bin/bash
set -e

echo "Initializing database..."

DB_USER="\${POSTGRES_USER:-rugi}"
DB_PASSWORD="\${POSTGRES_PASSWORD:-rugi_password}"
DB_NAME="\${POSTGRES_DB:-rugi_auth}"

psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname postgres <<-EOSQL
    SELECT 'CREATE DATABASE $DB_NAME'
    WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = '$DB_NAME')\\gexec
    GRANT ALL PRIVILEGES ON DATABASE $DB_NAME TO $DB_USER;
EOSQL

echo "Database initialization completed successfully!"
`
      );
      fs.chmodSync(path.join(projectPath, "docker", "init-db.sh"), 0o755);
    }
    fs.writeFileSync(
      path.join(projectPath, "package.json"),
      JSON.stringify(PACKAGE_JSON_TEMPLATE(name, includeDashboard), null, 2)
    );
    fs.writeFileSync(
      path.join(projectPath, "tsconfig.json"),
      JSON.stringify(TSCONFIG_TEMPLATE, null, 2)
    );

    spinner.succeed("Project structure created");

    // Generate RSA keys
    spinner.start("Generating RSA keys...");
    generateKeys(path.join(projectPath, "keys"));
    spinner.succeed("RSA keys generated");
    spinner.succeed("Docker configuration created");

    // Copy Prisma schema - try multiple paths for different install contexts
    spinner.start("Setting up Prisma schema...");
    const possibleSchemaPaths = [
      // When running from npm package (node_modules/rugi-auth/dist/cli)
      path.join(__dirname, "..", "..", "prisma", "schema.prisma"),
      // When running from source (src/cli)
      path.join(__dirname, "..", "..", "..", "prisma", "schema.prisma"),
      // When running from project root
      path.join(
        process.cwd(),
        "node_modules",
        "rugi-auth",
        "prisma",
        "schema.prisma"
      ),
    ];

    let schemaFound = false;
    for (const schemaPath of possibleSchemaPaths) {
      if (fs.existsSync(schemaPath)) {
        fs.copyFileSync(
          schemaPath,
          path.join(projectPath, "prisma", "schema.prisma")
        );
        schemaFound = true;
        break;
      }
    }

    if (!schemaFound) {
      // Download schema from npm registry or use inline schema
      fs.writeFileSync(
        path.join(projectPath, "prisma", "schema.prisma"),
        getPrismaSchemaContent()
      );
    }
    spinner.succeed("Prisma schema configured");

    // Install dependencies
    spinner.start("Installing backend dependencies...");
    execSync("npm install", { cwd: projectPath, stdio: "pipe" });
    spinner.succeed("Backend dependencies installed");

    // Setup dashboard if requested
    if (includeDashboard) {
      spinner.start("Cloning admin dashboard...");
      try {
        execSync(`git clone --depth 1 ${DASHBOARD_REPO} dashboard`, {
          cwd: projectPath,
          stdio: "pipe",
        });
        // Remove .git from cloned dashboard
        fs.rmSync(path.join(projectPath, "dashboard", ".git"), {
          recursive: true,
          force: true,
        });
        spinner.succeed("Admin dashboard cloned");

        spinner.start("Installing dashboard dependencies...");
        execSync("npm install", {
          cwd: path.join(projectPath, "dashboard"),
          stdio: "pipe",
        });
        spinner.succeed("Dashboard dependencies installed");

        // Create placeholder .env for dashboard (will be configured during setup)
        fs.writeFileSync(
          path.join(projectPath, "dashboard", ".env"),
          DASHBOARD_ENV_TEMPLATE(
            "http://localhost:7100",
            "rugi-dashboard-dev",
            "WILL_BE_SET_DURING_SETUP"
          )
        );
      } catch (dashboardError: any) {
        spinner.fail("Could not clone dashboard");
        console.log(
          chalk.yellow(
            "\n  âš  Dashboard clone failed, but dashboard scripts were added to package.json.\n"
          )
        );
        console.log(chalk.gray("  Possible reasons:"));
        console.log(chalk.gray(`    â€¢ Network connectivity issues`));
        console.log(
          chalk.gray(`    â€¢ Repository not accessible: ${DASHBOARD_REPO}`)
        );
        console.log(chalk.gray(`    â€¢ Git not installed or not in PATH`));
        console.log(chalk.gray(`    â€¢ Permission issues\n`));
        console.log(chalk.cyan("  To fix this later:"));
        console.log(
          chalk.cyan(`    Run: ${chalk.bold("npx rugi-auth update-dashboard")}`)
        );
        console.log(
          chalk.cyan(
            `    Or manually: ${chalk.bold(
              `git clone ${DASHBOARD_REPO} dashboard`
            )}\n`
          )
        );
        console.log(
          chalk.gray(
            "  Note: You can still use the backend without the dashboard.\n"
          )
        );
      }
    }

    // Success message
    console.log();
    console.log(chalk.green.bold("  âœ“ Project created successfully!\n"));
    console.log(chalk.bold("  Next steps:\n"));
    console.log(chalk.cyan(`  1. ${chalk.bold(`cd ${name}`)}`));
    console.log(
      chalk.cyan(
        `  2. ${chalk.bold("docker-compose up -d")}        ${chalk.gray(
          "# Start PostgreSQL"
        )}`
      )
    );
    console.log(
      chalk.cyan(
        `  3. ${chalk.bold("npm run prisma:migrate")}      ${chalk.gray(
          "# Run migrations"
        )}`
      )
    );
    console.log(
      chalk.cyan(
        `  4. ${chalk.bold("npm run setup")}               ${chalk.gray(
          "# Initialize app + superadmin"
        )}`
      )
    );

    if (includeDashboard) {
      console.log(
        chalk.cyan(
          `  5. ${chalk.bold("npm run dev:all")}             ${chalk.gray(
            "# Start backend + dashboard"
          )}`
        )
      );
      console.log();
      console.log(
        chalk.gray(`  Backend:   ${chalk.cyan("http://localhost:7100")}`)
      );
      console.log(
        chalk.gray(`  Dashboard: ${chalk.cyan("http://localhost:5173")}`)
      );
    } else {
      console.log(
        chalk.cyan(
          `  5. ${chalk.bold("npm run dev")}                 ${chalk.gray(
            "# Start development server"
          )}`
        )
      );
      console.log();
      console.log(
        chalk.gray(`  Server: ${chalk.cyan("http://localhost:7100")}`)
      );
    }

    console.log(
      chalk.gray(`  API Docs: ${chalk.cyan("http://localhost:7100/docs")}`)
    );
    console.log();
  } catch (error: any) {
    spinner.fail("Failed to create project");
    console.error(chalk.red(`\nError: ${error.message}\n`));
    process.exit(1);
  }
}

function generateKeys(keysDir?: string) {
  const dir = keysDir || path.join(process.cwd(), "keys");

  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }

  const privateKeyPath = path.join(dir, "private.pem");
  const publicKeyPath = path.join(dir, "public.pem");

  if (fs.existsSync(privateKeyPath) && !keysDir) {
    console.log(
      chalk.yellow("\nâš  Keys already exist. Delete them to regenerate.\n")
    );
    console.log(`  Private key: ${privateKeyPath}`);
    console.log(`  Public key: ${publicKeyPath}\n`);
    return;
  }

  const { publicKey, privateKey } = generateKeyPairSync("rsa", {
    modulusLength: 2048,
    publicKeyEncoding: { type: "spki", format: "pem" },
    privateKeyEncoding: { type: "pkcs8", format: "pem" },
  });

  fs.writeFileSync(privateKeyPath, privateKey, { mode: 0o600 });
  fs.writeFileSync(publicKeyPath, publicKey, { mode: 0o644 });

  if (!keysDir) {
    console.log(chalk.green("\nâœ“ RSA keys generated successfully!\n"));
    console.log(`  Private key: ${privateKeyPath}`);
    console.log(`  Public key: ${publicKeyPath}`);
    console.log(
      chalk.yellow("\n  âš  Never commit the private key to version control!\n")
    );
  }
}

interface AppCredentials {
  clientId: string;
  clientSecret: string;
  appName: string;
}

async function initApp(
  silent: boolean = false
): Promise<AppCredentials | null> {
  if (!silent) {
    printBanner();
  }

  const spinner = ora("Initializing default app...").start();

  try {
    // Dynamic import to avoid loading Prisma when not needed
    const { PrismaClient } = await import("@prisma/client");
    const { hashPassword } = await import("../services/password.service");
    const { v4: uuidv4 } = await import("uuid");

    const prisma = new PrismaClient();

    const DEFAULT_APP_NAME = "Rugi Dashboard";
    const DEFAULT_CLIENT_ID = "rugi-dashboard-dev";

    let app = await prisma.app.findFirst({
      where: { name: DEFAULT_APP_NAME },
      include: { authSettings: true },
    });

    const clientSecret = uuidv4() + uuidv4();
    const clientSecretHash = await hashPassword(clientSecret);

    if (!app) {
      app = await prisma.app.create({
        data: {
          name: DEFAULT_APP_NAME,
          clientId: DEFAULT_CLIENT_ID,
          clientSecretHash,
          type: "CONFIDENTIAL",
          redirectUris: [
            "http://localhost:3000/callback",
            "http://localhost:3001/callback",
            "http://localhost:5173/callback",
          ],
          authSettings: {
            create: {
              emailPasswordEnabled: true,
              emailOtpEnabled: false,
              googleAuthEnabled: false,
              githubAuthEnabled: false,
              microsoftAuthEnabled: false,
              facebookAuthEnabled: false,
              requireEmailVerification: false,
              allowRegistration: true,
            },
          },
        },
        include: { authSettings: true },
      });
    } else {
      app = await prisma.app.update({
        where: { id: app.id },
        data: { clientId: DEFAULT_CLIENT_ID, clientSecretHash },
        include: { authSettings: true },
      });
    }

    await prisma.$disconnect();

    spinner.succeed("Default app initialized");

    if (!silent) {
      console.log();
      console.log(chalk.bold("  ðŸ“± App Credentials\n"));
      console.log(
        chalk.gray("  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
      );
      console.log(`  ${chalk.cyan("App Name:")}      ${app.name}`);
      console.log(`  ${chalk.cyan("Client ID:")}     ${DEFAULT_CLIENT_ID}`);
      console.log(`  ${chalk.cyan("Client Secret:")} ${clientSecret}`);
      console.log(`  ${chalk.cyan("Type:")}          ${app.type}`);
      console.log(
        chalk.gray(
          "  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        )
      );
      console.log(
        chalk.yellow(
          "  ðŸ’¾ Save these credentials - the secret won't be shown again!\n"
        )
      );
    }

    return {
      clientId: DEFAULT_CLIENT_ID,
      clientSecret,
      appName: app.name,
    };
  } catch (error: any) {
    spinner.fail("Failed to initialize app");
    console.error(chalk.red(`\nError: ${error.message}\n`));
    console.log(
      chalk.gray(
        "  Make sure the database is running and migrations are applied.\n"
      )
    );
    if (!silent) {
      process.exit(1);
    }
    return null;
  }
}

async function createSuperadmin() {
  printBanner();

  console.log(chalk.bold("  Create your first superadmin account\n"));

  // Get email
  const emailResponse = await prompts({
    type: "text",
    name: "email",
    message: "Email address",
    validate: (value) =>
      /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value) || "Enter a valid email address",
  });

  if (!emailResponse.email) {
    console.log(chalk.red("\nâœ– Superadmin creation cancelled.\n"));
    process.exit(1);
  }

  // Get password
  const passwordResponse = await prompts({
    type: "password",
    name: "password",
    message: "Password (min 8 characters)",
    validate: (value) =>
      value.length >= 8 || "Password must be at least 8 characters",
  });

  if (!passwordResponse.password) {
    console.log(chalk.red("\nâœ– Superadmin creation cancelled.\n"));
    process.exit(1);
  }

  // Confirm password
  const confirmResponse = await prompts({
    type: "password",
    name: "confirmPassword",
    message: "Confirm password",
    validate: (value) =>
      value === passwordResponse.password || "Passwords do not match",
  });

  if (!confirmResponse.confirmPassword) {
    console.log(chalk.red("\nâœ– Superadmin creation cancelled.\n"));
    process.exit(1);
  }

  const response = {
    email: emailResponse.email,
    password: passwordResponse.password,
  };

  const spinner = ora("Creating superadmin...").start();

  try {
    const { PrismaClient } = await import("@prisma/client");
    const { hashPassword } = await import("../services/password.service");

    const prisma = new PrismaClient();

    // Check if user exists
    const existingUser = await prisma.user.findUnique({
      where: { email: response.email },
    });

    if (existingUser) {
      spinner.fail("User with this email already exists");
      await prisma.$disconnect();
      process.exit(1);
    }

    // Get default app
    const app = await prisma.app.findFirst({
      where: { clientId: "rugi-dashboard-dev" },
    });

    if (!app) {
      spinner.fail(
        "Default app not found. Run 'npx rugi-auth init-app' first."
      );
      await prisma.$disconnect();
      process.exit(1);
    }

    // Create user
    const passwordHash = await hashPassword(response.password);
    const user = await prisma.user.create({
      data: {
        email: response.email,
        passwordHash,
        isEmailVerified: true,
        optedInApps: [app.id],
      },
    });

    // Create superadmin and owner roles if they don't exist
    const superadminRole = await prisma.role.upsert({
      where: { appId_name: { appId: app.id, name: "superadmin" } },
      create: { appId: app.id, name: "superadmin" },
      update: {},
    });

    const ownerRole = await prisma.role.upsert({
      where: { appId_name: { appId: app.id, name: "owner" } },
      create: { appId: app.id, name: "owner" },
      update: {},
    });

    // Assign roles to user
    await prisma.userAppRole.createMany({
      data: [
        { userId: user.id, roleId: superadminRole.id },
        { userId: user.id, roleId: ownerRole.id },
      ],
    });

    await prisma.$disconnect();

    spinner.succeed("Superadmin created successfully");

    console.log();
    console.log(chalk.bold("  ðŸ‘¤ Superadmin Account\n"));
    console.log(
      chalk.gray("  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
    );
    console.log(`  ${chalk.cyan("Email:")}  ${response.email}`);
    console.log(`  ${chalk.cyan("Roles:")}  superadmin, owner`);
    console.log(
      chalk.gray("  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n")
    );
    console.log(
      chalk.green("  ðŸŽ‰ You can now log in to your Rugi Auth server!\n")
    );
  } catch (error: any) {
    spinner.fail("Failed to create superadmin");
    console.error(chalk.red(`\nError: ${error.message}\n`));
    process.exit(1);
  }
}

async function runSetup() {
  printBanner();

  console.log(chalk.bold("  Running complete setup...\n"));

  // Step 1: Generate keys if needed
  const keysDir = path.join(process.cwd(), "keys");
  const privateKeyPath = path.join(keysDir, "private.pem");

  if (!fs.existsSync(privateKeyPath)) {
    const spinner = ora("Generating RSA keys...").start();
    generateKeys(keysDir);
    spinner.succeed("RSA keys generated");
  } else {
    console.log(chalk.gray("  âœ“ RSA keys already exist\n"));
  }

  // Step 2: Initialize app and get credentials
  const credentials = await initApp(true);

  if (credentials) {
    console.log();
    console.log(chalk.bold("  ðŸ“± App Credentials\n"));
    console.log(
      chalk.gray("  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
    );
    console.log(`  ${chalk.cyan("App Name:")}      ${credentials.appName}`);
    console.log(`  ${chalk.cyan("Client ID:")}     ${credentials.clientId}`);
    console.log(
      `  ${chalk.cyan("Client Secret:")} ${credentials.clientSecret}`
    );
    console.log(
      chalk.gray("  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n")
    );

    // Step 3: Configure dashboard if it exists
    const dashboardPath = path.join(process.cwd(), "dashboard");
    const dashboardEnvPath = path.join(dashboardPath, ".env");

    if (fs.existsSync(dashboardPath)) {
      const spinner = ora("Configuring dashboard...").start();
      fs.writeFileSync(
        dashboardEnvPath,
        DASHBOARD_ENV_TEMPLATE(
          "http://localhost:7100",
          credentials.clientId,
          credentials.clientSecret
        )
      );
      spinner.succeed("Dashboard configured with credentials");
    }
  }

  // Step 4: Create superadmin
  await createSuperadmin();

  // Check if dashboard exists for final message
  const hasDashboard = fs.existsSync(path.join(process.cwd(), "dashboard"));

  console.log(chalk.green.bold("\n  âœ“ Setup complete!\n"));

  if (hasDashboard) {
    console.log(chalk.bold("  Start your servers:\n"));
    console.log(
      `    ${chalk.cyan("npm run dev:all")}     ${chalk.gray(
        "# Backend + Dashboard"
      )}`
    );
    console.log();
    console.log(chalk.gray("  Or separately:"));
    console.log(
      `    ${chalk.cyan("npm run dev")}          ${chalk.gray(
        "# Backend only (port 7100)"
      )}`
    );
    console.log(
      `    ${chalk.cyan("npm run dashboard:dev")} ${chalk.gray(
        "# Dashboard only (port 5173)"
      )}`
    );
  } else {
    console.log(`  Start your server with: ${chalk.cyan("npm run dev")}`);
  }

  console.log();
  console.log(chalk.bold("  ðŸ” Login Credentials:\n"));
  console.log(
    chalk.gray("  Use the email and password you just created to log in.")
  );
  if (hasDashboard) {
    console.log(
      chalk.gray(`  Dashboard URL: ${chalk.cyan("http://localhost:5173")}`)
    );
  }
  console.log();
}

/**
 * Diagnose why dashboard might be missing and provide helpful information
 */
function diagnoseMissingDashboard(): void {
  const dashboardPath = path.join(process.cwd(), "dashboard");
  const packageJsonPath = path.join(process.cwd(), "package.json");

  console.log(chalk.yellow("\n  Diagnosing missing dashboard...\n"));

  // Check if package.json exists and has dashboard scripts
  let hasDashboardScripts = false;
  if (fs.existsSync(packageJsonPath)) {
    try {
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, "utf-8"));
      hasDashboardScripts =
        packageJson.scripts &&
        (packageJson.scripts["dashboard:dev"] ||
          packageJson.scripts["dev:all"]);
    } catch (error) {
      // Ignore parse errors
    }
  }

  // Check if we're in a rugi-auth project
  const hasServerFiles =
    fs.existsSync(path.join(process.cwd(), "src", "server.ts")) ||
    fs.existsSync(path.join(process.cwd(), "server.ts"));

  console.log(chalk.gray("  Current directory: ") + chalk.cyan(process.cwd()));
  console.log(chalk.gray("  Dashboard path: ") + chalk.cyan(dashboardPath));
  console.log(
    chalk.gray("  Has dashboard scripts: ") +
      (hasDashboardScripts ? chalk.green("Yes") : chalk.red("No"))
  );
  console.log(
    chalk.gray("  Looks like rugi-auth project: ") +
      (hasServerFiles ? chalk.green("Yes") : chalk.red("No"))
  );
  console.log();

  if (hasDashboardScripts && !fs.existsSync(dashboardPath)) {
    console.log(
      chalk.yellow("  âš  Dashboard scripts found but directory is missing.\n")
    );
    console.log(chalk.gray("  Possible reasons:"));
    console.log(
      chalk.gray("    1. Dashboard clone failed during 'npx rugi-auth init'")
    );
    console.log(chalk.gray("    2. Dashboard directory was manually deleted"));
    console.log(chalk.gray("    3. Network issues prevented git clone"));
    console.log(chalk.gray("    4. Repository access issues\n"));
    console.log(chalk.cyan("  Solutions:"));
    console.log(
      chalk.cyan(`    1. Run: ${chalk.bold("npx rugi-auth update-dashboard")}`)
    );
    console.log(
      chalk.cyan(
        `    2. Or manually clone: ${chalk.bold(
          `git clone ${DASHBOARD_REPO} dashboard`
        )}`
      )
    );
    console.log(
      chalk.cyan(
        `    3. Or remove dashboard scripts from package.json if not needed\n`
      )
    );
  } else if (!hasDashboardScripts && !hasServerFiles) {
    console.log(
      chalk.yellow("  âš  This doesn't appear to be a rugi-auth project.\n")
    );
    console.log(
      chalk.cyan(
        `  Run: ${chalk.bold(
          "npx rugi-auth init [project-name]"
        )} to create a new project\n`
      )
    );
  } else if (!hasDashboardScripts) {
    console.log(
      chalk.yellow(
        "  âš  Dashboard was not included during project initialization.\n"
      )
    );
    console.log(
      chalk.cyan(
        `  Re-run: ${chalk.bold(
          "npx rugi-auth init"
        )} and select 'Yes' for dashboard option\n`
      )
    );
  }
}

async function updateDashboard() {
  printBanner();

  const dashboardPath = path.join(process.cwd(), "dashboard");

  if (!fs.existsSync(dashboardPath)) {
    console.log(chalk.red("\nâœ– Dashboard not found in current directory.\n"));
    diagnoseMissingDashboard();
    process.exit(1);
  }

  console.log(chalk.bold("  Updating admin dashboard...\n"));

  const spinner = ora("Checking dashboard status...").start();

  try {
    // Check if it's a git repository
    const gitPath = path.join(dashboardPath, ".git");
    if (!fs.existsSync(gitPath)) {
      spinner.fail("Dashboard is not a git repository");
      console.log(
        chalk.yellow("\n  Dashboard was not cloned from git. Re-cloning...\n")
      );

      // Backup .env if it exists
      const envPath = path.join(dashboardPath, ".env");
      let savedEnv = "";
      if (fs.existsSync(envPath)) {
        savedEnv = fs.readFileSync(envPath, "utf-8");
        console.log(chalk.gray("  âœ“ Backed up .env file\n"));
      }

      // Remove old dashboard
      spinner.start("Removing old dashboard...");
      fs.rmSync(dashboardPath, { recursive: true, force: true });
      spinner.succeed("Old dashboard removed");

      // Clone fresh
      spinner.start("Cloning latest dashboard...");
      execSync(`git clone --depth 1 ${DASHBOARD_REPO} dashboard`, {
        cwd: process.cwd(),
        stdio: "pipe",
      });
      // Remove .git from cloned dashboard
      fs.rmSync(path.join(dashboardPath, ".git"), {
        recursive: true,
        force: true,
      });
      spinner.succeed("Latest dashboard cloned");

      // Restore .env if it existed
      if (savedEnv) {
        fs.writeFileSync(envPath, savedEnv);
        console.log(chalk.gray("  âœ“ Restored .env file\n"));
      }

      // Install dependencies
      spinner.start("Installing dashboard dependencies...");
      execSync("npm install", { cwd: dashboardPath, stdio: "pipe" });
      spinner.succeed("Dashboard dependencies installed");

      console.log(chalk.green.bold("\n  âœ“ Dashboard updated successfully!\n"));
      return;
    }

    // It's a git repo, try to pull updates
    spinner.start("Fetching latest changes...");

    // Stash any local changes
    try {
      execSync("git stash", { cwd: dashboardPath, stdio: "pipe" });
    } catch {
      // No changes to stash, that's fine
    }

    // Fetch and pull
    execSync("git fetch origin", { cwd: dashboardPath, stdio: "pipe" });
    execSync("git pull origin main", { cwd: dashboardPath, stdio: "pipe" });

    spinner.succeed("Dashboard updated from git");

    // Install dependencies in case package.json changed
    spinner.start("Updating dependencies...");
    execSync("npm install", { cwd: dashboardPath, stdio: "pipe" });
    spinner.succeed("Dependencies updated");

    console.log(chalk.green.bold("\n  âœ“ Dashboard updated successfully!\n"));
    console.log(
      chalk.gray("  Restart your dashboard with: npm run dashboard:dev\n")
    );
  } catch (error: any) {
    spinner.fail("Failed to update dashboard");
    console.error(chalk.red(`\nError: ${error.message}\n`));
    console.log(
      chalk.yellow("  You may need to manually update the dashboard:\n")
    );
    console.log(chalk.cyan(`  cd dashboard`));
    console.log(chalk.cyan(`  git pull origin main`));
    console.log(chalk.cyan(`  npm install\n`));
    process.exit(1);
  }
}

// ============================================================
// CLI Program Definition
// ============================================================

program
  .name("rugi-auth")
  .description("Centralized authentication service CLI")
  .version(VERSION);

program
  .command("init [project-name]")
  .description("Create a new rugi-auth project")
  .action(initProject);

program
  .command("generate-keys")
  .description("Generate RSA key pair for JWT signing")
  .action(() => generateKeys());

program
  .command("init-app")
  .description("Initialize the default application with credentials")
  .action(async () => {
    await initApp(false);
  });

program
  .command("create-superadmin")
  .description("Create a superadmin user")
  .action(createSuperadmin);

program
  .command("setup")
  .description("Run complete setup (keys + app + superadmin)")
  .action(runSetup);

program
  .command("diagnose-dashboard")
  .description("Diagnose why dashboard might be missing")
  .action(() => {
    printBanner();
    diagnoseMissingDashboard();
  });

program
  .command("update-dashboard")
  .description("Update the admin dashboard to the latest version")
  .action(updateDashboard);

// Check for updates asynchronously (non-blocking)
checkForUpdates().catch(() => {
  // Silently fail - don't block CLI if check fails
});

program.parse();

